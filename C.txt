>>>基本の書き方-------------------------------------------------------------------------------------------------------------------------------------------

記述するファイル名に任意の名前(半角英数字推奨)と末尾に.cと拡張子を書くこと。
以下ファイル内での記述方法

#include <インクルードしたいライブラリ>

int main(void) {
    ここに処理内容

    return 0;
}

>>>文字表示----------------------------------------------------------------------------------------------------------------------------------------------

・必須ライブラリ
stdio.h
locale.h
wchar.h
・表示前準備(任意の場所かつ表示前にプログラム中1度だけでOK)
setlocale(LC_ALL, "");
・表示処理
wprintf(L"表示したい文字をここに記述");
※%dなど変換指定を文字列の中に書けば変換指定を書いた順とその後の実引数の場所と対応してその実引数の値を表示できる。
例1
wprintf(L"現在の値は%dです。\n", 100);  //「現在の値は100です。」と表示される
例2
wprintf(L"現在の値は%dと%dです。\n", 100, 200);  //「現在の値は100と200です。」と表示される

・変換指定一覧(代表的なもののみ)
%d    対応する実引数を符号付き10進数で表示
%u    対応する実引数を符号無し10進数で表示
%o    対応する実引数を8進数で表示
%x    対応する実引数を16進数で表示
%ls   対応する実引数をワイド文字列で表示
%f    対応する実引数を小数で表示

>>>変数--------------------------------------------------------------------------------------------------------------------------------------------------

宣言方法
型名 変数名;

例1
int a;  //int型の変数aを宣言
例2
int x, y, z;  //1行で複数の宣言も可能

[[重要]]変数は初期化が必要
変数は宣言しただけでは不定値というゴミの値が入っているため安全な値に上書きしなければならず、これを初期化という。
初期化の方法
例1
a = 0;  //既に宣言されている変数に型に合った任意の値を代入
例2
int b = 10;  //変数宣言と初期化を1行で行う書き方

変数名の命名ルールについて
変数名には半角英数字とアンダーバーを使うことができ、変数名の先頭に数字を使うことはできない。
また、変数名はプログラム中で一意である必要があり、C言語で予約されているものを使うことはできない。
※C言語で予約されているものとは、intなどの型名や、後述するifやwhileなどのキーワードのこと。

>>>演算--------------------------------------------------------------------------------------------------------------------------------------------------

a = 1 + 2;  //変数aに1 + 2の計算結果を上書き
a += 3;  //変数aの現在の中身にそのまま3を加算

四則演算の演算子は以下の通り
+  加算
-  減算
*  乗算
/  除算
その他
%  剰余

変数同士や変数に対して計算するときは基本的に同じ型同士で計算することが推奨。
C言語の仕様上異なる型同士でも計算は可能だが、コードの可読性が低下する。

インクリメントとデクリメント
a++;  //aに1加算(インクリメント)
a--;  //aから1減算(デクリメント)

前置と後置
b = ++a;  //aをインクリメントしてからbに代入
b = a++;  //bにaを代入した後aをインクリメント

>>>型----------------------------------------------------------------------------------------------------------------------------------------------------

型一覧(以下はWindowsの場合。他OSでは同じ型名でもバイト数と最大値・最小値が異なる場合がある。)
char        1バイト(8bit)   -128~127
short       2バイト(16bit)  -32768~32767
int         4バイト(32bit)  -2147483648~2147483647
long        intと同じ       intと同じ
long long   8バイト(64bit)  -9223372036854775808~9223372036854775807
float       4バイト(32bit)  単精度浮動小数点数
double      8バイト(64bit)  倍精度浮動小数点数
※浮動小数点型については最大値最小値を省略。知りたい場合は自身で調べるべし

型名の前にsignedまたはunsignedを付けることで符号の有り無しを指定できる。
signedが符号あり、unsignedが符号なしになる
例
unsigned int  //int型で、バイト数は変わらないが負の値を表さないという意味になり、0~4294967295まで表現できるようになる

型のキャスト
例
unsigned char a = 10;
unsigned int b = (int)a;  //このように書くと、bに代入するその時だけaを一時的にint型として解釈して代入するという動きになる(a自体がint型になったわけではない)
上記の例の場合は比較的安全だが、符号有り無しが異なっていたり、キャスト先が小さい型の場合などは中身の値が変更される場合がある。

>>>if文----------------------------------------------------------------------------------------------------------------------------------------------------

if文の書き方
if (条件式) {
    条件式がtrueになるときの処理
}

条件式の書き方(今後、条件式と書かれた部分はこれに該当する)
条件式は、その式の結果が非ゼロであればtrue、ゼロであればfalseとなるのがC言語の仕様。
極端に言うと条件式に1と書けば必ずtrueとなり実行される。逆に0と書けば必ずfalseとなり実行されない。
以下条件式例
a > b   //aがbより大きいならtrue
a < b   //aがb未満ならtrue
a >= b  //aがb以上ならtrue
a <= b  //aがb以下ならtrue
a == b  //aとbが等しいならtrue
a != b  //aとbが等しくないならtrue
a && b  //aとbがどちらもtrueならばtrue
a || b  //aまたはbのどちらかがtrueならばtrue
なお、条件式は異なる型では比較できない。また、浮動小数点型は比較として使うには非推奨。
!aのように条件式を書くと、aの中身がtrueならfalseになり、逆にfalseならtrueになる。

条件式は複合して書くこともできる
例
a == b && c == d  //この場合はaとbの比較、cとdの比較がどちらもtrueであればtrueになる。

elseについて
ifは条件式がfalseの場合はその処理が実行されない。しかし、ifが実行されなかった場合に実行するという意味を持たせるelseがある
書き方は以下の通り
if (条件式) {
    条件式がtrueになるときの処理
} else {
    上の処理が実行されなかった場合にここが実行される
}

else ifについて
elseに来た場合、さらにそこから条件式で判定を行うこともできる
書き方は以下の通り
if (条件式1) {
    条件式1がtrueになるときの処理
} else if (条件式2) {
    条件式1がfalseの場合かつ条件式2がtrueになるときの処理
}

また、ifでtrueになった場合の処理が1行で書ける場合は{}無しでも記述できる。
例
if (条件式1) 条件式1がtrueになるときの処理;
else if (条件式2) 条件式1がfalseの場合かつ条件式2がtrueになるときの処理;
else 上の処理が実行されなかった場合にここが実行される;

三項演算子について
C言語にはifに似たものとして三項演算子というものがある。
書き方は以下の通り
(条件式) ? trueの場合の値 : falseの場合の値

三項演算子は1行で記述でき、条件式の評価次第でどちらかの値を返してくれる。
例
int a = (x < y) ? 10 : 100;  //この場合、xがy未満なら10が変数aに代入され、そうでないなら100が変数aに代入される

>>>switch文-----------------------------------------------------------------------------------------------------------------------------------------------

switch文の書き方
switch (条件となる値) {
    case 整数1 : {
        整数1と条件となる値が同じ時にここが処理される
        break;
    }
    case 整数2 : {
        整数2と条件となる値が同じ時にここが処理される
        break;
    }
    default : {
        どのcaseにも該当しなかった場合にここが処理される
        break;
    }
}

条件となる値(変数でも可)とcaseと:の間に書かれる値は必ず整数でなければならない。浮動小数点型や文字列は不可。
各処理後は必ずbreakを書かなければならない。

>>>do文--------------------------------------------------------------------------------------------------------------------------------------------------

do文はプログラム中にループ処理を書くための構文の一つ
do文の書き方
do {
    繰り返し行いたい処理
} while (条件式);

最初に繰り返し行いたい処理が実行され、その後、条件式を評価してtrueならば再度繰り返し行いたい処理が実行される。
条件式がtrueである限り無限に繰り返される。
繰り返し行う予定だが、最低でも1回は必ず実行したい場合に最適。

また、ループ処理を行う構文ではcontinueとbreakというものが使える。
continueはそれが書かれた行に到達したとき、残りの処理をスキップして条件式評価へジャンプする。
breakはそれが書かれた行に到達したとき、残りの処理をスキップしてループ自体から抜ける。

>>>while文----------------------------------------------------------------------------------------------------------------------------------------------

while文もプログラム中にループ処理を書くための構文の一つ
while文の書き方
while (条件式) {
    繰り返し行いたい処理
}

最初に条件式を評価し、trueならば繰り返し行いたい処理が実行される。
条件式がtrueである限り無限に繰り返されるのはdoと同じだが、while文は条件式の評価から入るため、最初からfalseの場合は一切実行されない。

>>>for文-------------------------------------------------------------------------------------------------------------------------------------------------

for文もプログラム中にループ処理を書くための構文の一つ
for文の書き方
for (初期化式; 条件式; 変化式) {
    繰り返し行いたい処理
}

初期化式とは、主にそのfor文内で一時的に使う変数の宣言などに使われる部分。
変化式とは、主に初期化式で宣言した変数などに計算を行う部分。

for文は最初に初期化式を実行し、次に条件式を評価してtrueならば繰り返し行いたい処理が実行され、その後変化式が実行されて再度条件式を評価…という流れになる。
一定回数だけ繰り返したいときに最適。

また、for文のみcontinueの挙動が他二つのループ処理構文と異なり、continueと書かれた行に到達したとき、変化式の実行へジャンプする。

>>>配列---------------------------------------------------------------------------------------------------------------------------------------------------

配列とは、一つの変数で同型の複数の値を保持するのに役立つもの。
配列の宣言方法
型名 配列名[配列の長さ];

例1
int a[5];  //int型の配列aを長さ5で宣言
例2
int b[3] = {0};  //int型の配列bを長さ3で宣言し、全要素を0で初期化
例3
int c[] = {24, 50, 35, 97};  //int型の配列cを{}の中の値の個数で長さを宣言し、同時に対応する値で各要素を初期化
※例1では各要素は未初期化のためそのままの使用は未定義動作のため危険。また、例2の初期化方法は例3のように配列の長さを指定していない宣言方法には使えない。

配列のアクセス方法
配列名[インデックス]

例
int d = c[0];  //int型の変数dに同じint型の配列cのインデックス0番目の値を代入。今回の場合は24が代入される。

配列は長さを持っていて、最初に書いたように1つの変数で複数の値を持つことができる。
int型で長さを5で宣言すれば、5個分のint型領域が確保され、その各領域を要素という。
また、各要素を指すためのアクセス時に使う数字をインデックスという。

配列にアクセスする時のインデックスは整数型の変数でも可能。unsignedの符号無し整数型が好ましい。
例
unsigned int index = 2;
int value = c[index];  //int型の変数valueに配列cのインデックス2番目の値を代入

配列は宣言したとき、インデックスは0から始まるため、例えば長さ5で宣言したときにアクセスできるインデックスは0~4となる。
[[重要]]配列の範囲外のインデックスにアクセスすると未定義動作になるため、大変危険。
危険な例
int e[7] = {0};
int f = e[7];  //配列eのインデックスは6までなので未定義動作

多次元配列について
一般的なプログラミング言語では多次元配列というものが可能。
例えば2次元配列ならば配列の中に配列を入れるといった感じ。

例1
int g[2][5] = { {1, 2, 3, 4, 5}, {6, 7, 8, 9, 10} };  //int型の配列gを長さ2、さらにその中の各要素に同型で長さ5で宣言し、対応する値で初期化
例2(アクセス方法)
int h = g[1][3];  //int型の変数hに配列gのインデックス1-3番目の値を代入。今回の場合は9が代入される。
※多次元配列では宣言時に全ての長さを指定して宣言すること。

>>>関数---------------------------------------------------------------------------------------------------------------------------------------------------

関数とは、プログラム中に何度も出てくるような処理を一纏めにして名前を付け、その名前を書くことで呼び出すことのできるものである。
関数の宣言方法は以下の通り
返却型 関数名(仮引数) {
    ここに呼び出されたときの処理を記述
}

関数の呼び出しは関数の中で行えるが、関数の宣言は関数の中で行うことはできない。
そして、呼び出したい関数はその呼び出す行よりも上に宣言されていなければならない。
また、関数名は変数名の命名ルールと同様である。

例1
int add(int a, int b) {
    int answer = a + b;
    return answer;
}
例2(呼び出し)
int value = add(2, 3);  //変数valueには5が代入される

例1の最初の行では、まず、int型の値を呼び出し元に返すことを約束し、その後呼び出すための関数名を書いている。
更に、()の中の仮引数ではその関数内でのみ使い、かつ呼び出し元との窓口となる一時的な変数を宣言する。
その後、{}の中に処理を書いていき、最後に今回のadd関数はint型の値を返すことを約束しているため、
関数内で宣言したint型の変数answerの中身を返すために、returnという記述の後にanswerと書いている。

例2の呼び出しでは、add関数はint型の値を返すことが約束されているため、int型でvalueという変数を宣言し、
呼び出す関数名addを記述したのち間を開けずに()を記述。そして()の中に、add関数が用意している仮引数の型と同じ型の値を書く。
今回のadd関数は仮引数が二つあるため、呼び出す場合も二つ値を渡さなければならない。
結果、例2ではadd関数に2と3という二つのint型の値がそれぞれ仮引数aとbに代入され、
処理が行われて呼び出し元となる変数valueに5が代入される。

仮引数無しで関数を宣言する場合は()の中にvoidと記述する。
例1
int zero(void) {
    return 0;  //int型である0を呼び出し元に返している
}
例2(呼び出し)
int x = zero();  //呼び出すときは関数名の後にただの()だけでOK

呼び出したとしても何も返さない関数を宣言する場合は返却型にvoidと記述する。
例1
void say(int a) {
    wprintf(L"%dという数値が渡されました。\n", a);  //仮引数の値を表示しているだけなので何も返していない
}
例2(呼び出し)
say(5);  //関数名を書くだけ。今回の場合は「5という数値が渡されました。」と表示される
また、返却型がvoidの関数は最後にreturnを書かなくてよい。

returnについて
returnは呼び出し元に返却型の値を返す役割のほかに、記述された行に到達したとき、その関数の実行を即終了する役割も持っている。
例
int judge(int a, int b) {
    if (a > b) return a;  //もしaがbより大きかった場合、aの値が呼び出し元に返され、その下の行のreturn b;は実行されずこの関数は終了する
    return b;
}
また、返却型がvoidの関数の場合でもreturn;と記述すればその行に到達したときにその関数の処理を中断できる。

このC言語説明書の冒頭で書いたint main(void) {}も関数である。
main関数はC言語の規定により、コンピューターがプログラムを実行するときに最初に呼び出す関数として決まっている。
このような関数を「エントリーポイント」という。
main関数の最後にreturn 0;と書くのは、プログラムが正常に終了したことを通知するために呼び出し元であるコンピューターにint型の0を返すためである。
return 1;と記述してmain関数が終了した場合、コンピューターはプログラムが異常終了したと認識する。

>>>変数の有効範囲(スコープ)---------------------------------------------------------------------------------------------------------------------------------